#
# cloudbuild.yaml for building and testing vertx-template with Oracle DB and Postgres in GCB
#

# Google Cloud KMS KeyRing and CryptoKey are created for encrypting credentials of SourceClear and Docker Store
# Container Builder service account is granted access to the CryptoKey.
# Run the following command in shell or terminal window to encrpt SourceClear and Docker Store credentials
# MY_SECRET=<enter-your-credential>
# echo -n $MY_SECRET | gcloud kms encrypt --plaintext-file=- --ciphertext-file=- \
# --location=global --keyring=[KEYRING-NAME] --key=[KEY-NAME] | base64

# See below link for more information on using Google Cloud KMS:
# https://cloud.google.com/container-builder/docs/securing-builds/use-encrypted-secrets-credentials#encrypting_an_environment_variable_using_the_cryptokey

secrets:
- kmsKeyName: 'projects/[GCP-PROJECT-ID]/locations/global/keyRings/[GCP-KMS-KEYRING-NAME]/cryptoKeys/[GCP-KMS-KEY-NAME]'
  secretEnv:
    SRCCLR_API_TOKEN:[ENCRYPTED-SOURCECLEAR-AGENT-API-TOKEN]
    DOCKER_USERNAME: [ENCRYPTED-DOCKER-USERNAME]
    DOCKER_PASSWORD: [ENCRYPTED-DOCKER-PASSWORD]

# Build Steps:
steps:

#
# Steps for building and testing vertx-template with Oracle DB
#

# Copying ojdbc7 dependency in GCB workspace
- name: 'gcr.io/cloud-builders/gsutil'
  args: ['cp', 'gs://[GCS-BUCKET-HOSTING-OJDBC7.JAR]/ojdbc7.jar', 'ojdbc7.jar']

# Copying sample.properties and pom.xml
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "cp ./oracle_sample.properties ./sample.properties; cp ./oracle_pom.xml ./pom.xml"]

# Authenticating to Docker Store
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', 'docker login --username=$$DOCKER_USERNAME --password=$$DOCKER_PASSWORD']
  secretEnv: ['DOCKER_USERNAME', 'DOCKER_PASSWORD']

# Creating a separate network
# It is required for communication between Oracle DB server and APP server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', 'docker network create $$ORACLEDB_NET']
  env: ['ORACLEDB_NET=stanford-oracledb']

# Creating an Oracle DB server 
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker run -d --name $$ORACLEDB_SERVER --net $$ORACLEDB_NET \
         -v /workspace:/workspace $$ORACLEDB_IMAGE"]
  env: ['ORACLEDB_IMAGE=store/oracle/database-enterprise:12.2.0.1-slim', 'ORACLEDB_SERVER=oracle-dbserver',
        'ORACLEDB_NET=stanford-oracledb']

# Building application jar using APP build server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker run --name $$APP_BUILD_SERVER --net $$ORACLEDB_NET -e SRCCLR_API_TOKEN \
         -v /workspace:/workspace --entrypoint 'bash' $$APP_BUILD_IMAGE \
         -c 'apt-get update; apt-get install curl -y; cd /workspace; \
         mvn install:install-file -Dfile=./ojdbc7.jar -DgroupId=com.oracle.jdbc -DartifactId=ojdbc7 \
         -Dversion=12.1.0.2 -Dpackaging=jar; mvn -DskipTests clean package; \
         curl -sSL https://download.sourceclear.com/ci.sh | sh'"]
  env: ['APP_BUILD_SERVER=oracledb-app-build-server', 'ORACLEDB_NET=stanford-oracledb',
        'APP_BUILD_IMAGE=gcr.io/cloud-builders/mvn']
  secretEnv: ['SRCCLR_API_TOKEN']

# Checking the health of Oracle DB server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', './check_oracledb_health.sh']
  env: ['DB_HLTH_CHK_MAX_RETRY=7', 'DB_HLTH_CHK_SLEEP=20', 'ORACLEDB_SERVER=oracle-dbserver']

# Testing application jar using APP test server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker run -d --name $$APP_TEST_SERVER --net $$ORACLEDB_NET \
         -v /workspace:/workspace --entrypoint 'bash' $$APP_TEST_IMAGE -c 'cd /workspace; \
         java -Djava.security.egd=file:/dev/./urandom -jar /workspace/target/vertx-*-SNAPSHOT.jar create-database run'"]
  env: ['APP_TEST_SERVER=oracledb-app-test-server', 'ORACLEDB_NET=stanford-oracledb',
        'APP_TEST_IMAGE=gcr.io/cloud-builders/mvn']

# Checking database table created by application jar
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker exec -e ORACLEDB_SERVER -e DB_TBL_CHK_MAX_RETRY \
         -e DB_TBL_CHK_SLEEP $$ORACLEDB_SERVER bash -c '/workspace/check_oracledb_table.sh'"]
  env: ['DB_TBL_CHK_MAX_RETRY=10', 'DB_TBL_CHK_SLEEP=10', 'ORACLEDB_SERVER=oracle-dbserver']

# Building GCR image for application jar
- name: 'gcr.io/cloud-builders/docker'
  args: ['build', '-t', 'gcr.io/$PROJECT_ID/vertx-template-oracledb:latest', '-f', 'Dockerfile_oracledb', '.']

#
# Steps for building and testing vertx-template with Postgres
#

# Creating a separate network
# It is required for communication between Postgres server and APP server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', 'docker network create $$POSTGRES_NET']
  env: ['POSTGRES_NET=stanford-postgres']

# Copying sample.properties and pom.xml
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "cp ./postgres_sample.properties ./sample.properties; cp ./postgres_pom.xml pom.xml"]

# Creating a Postgres server 
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker run -d --name $$POSTGRES_SERVER --net $$POSTGRES_NET \
         -e POSTGRES_USER -e POSTGRES_PASSWORD -e POSTGRES_DB \
         -v /workspace:/workspace $$POSTGRES_IMAGE"]
  env: ['POSTGRES_IMAGE=postgres:9.3', 'POSTGRES_USER=test', 'POSTGRES_PASSWORD=test', 'POSTGRES_DB=test',
        'POSTGRES_SERVER=postgres-dbserver', 'POSTGRES_NET=stanford-postgres']

# Building application jar using APP build server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker run --name $$APP_BUILD_SERVER --net $$POSTGRES_NET -e SRCCLR_API_TOKEN \
         -v /workspace:/workspace --entrypoint 'bash' $$APP_BUILD_IMAGE \
         -c 'apt-get update; apt-get install curl -y; cd /workspace; mvn -DskipTests -Ppostgres clean package; \
         curl -sSL https://download.sourceclear.com/ci.sh | sh'"]
  env: ['APP_BUILD_SERVER=postgres-app-build-server', 'POSTGRES_NET=stanford-postgres',
        'APP_BUILD_IMAGE=gcr.io/cloud-builders/mvn']
  secretEnv: ['SRCCLR_API_TOKEN']

# Checking the health of Postgres server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker exec -e POSTGRES_SERVER -e DB_HLTH_CHK_MAX_RETRY \
         -e DB_HLTH_CHK_SLEEP $$POSTGRES_SERVER /workspace/check_postgres_health.sh"]
  env: ['DB_HLTH_CHK_MAX_RETRY=7', 'DB_HLTH_CHK_SLEEP=20', 'POSTGRES_SERVER=postgres-dbserver']

# Testing application jar using APP test server
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker run -d --name $$APP_TEST_SERVER --net $$POSTGRES_NET \
         -v /workspace:/workspace --entrypoint 'bash' $$APP_TEST_IMAGE \
         -c 'cd /workspace; java -jar /workspace/target/vertx-*-SNAPSHOT.jar create-database run'"]
  env: ['APP_TEST_SERVER=postgres-app-test-server', 'POSTGRES_NET=stanford-postgres',
        'APP_TEST_IMAGE=gcr.io/cloud-builders/mvn']

# Checking database table created by application jar
- name: 'gcr.io/cloud-builders/docker'
  entrypoint: 'bash'
  args: ['-c', "docker exec -e POSTGRES_SERVER -e DB_TBL_CHK_MAX_RETRY \
         -e DB_TBL_CHK_SLEEP $$POSTGRES_SERVER bash -c '/workspace/check_postgres_table.sh'"]
  env: ['DB_TBL_CHK_MAX_RETRY=10', 'DB_TBL_CHK_SLEEP=10', 'POSTGRES_SERVER=postgres-dbserver']

# Building GCR image for application jar
- name: 'gcr.io/cloud-builders/docker'
  args: ['build', '-t', 'gcr.io/$PROJECT_ID/vertx-template-postgres:latest', '-f', 'Dockerfile_postgres', '.']

#
# Uploading GCR images for application jar
#
images:
  - 'gcr.io/$PROJECT_ID/vertx-template-postgres:latest'
  - 'gcr.io/$PROJECT_ID/vertx-template-oracledb:latest'
